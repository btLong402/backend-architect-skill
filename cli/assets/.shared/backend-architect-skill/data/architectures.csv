id,name,description,use_case,trade_offs,key_components,ref_pattern
arch_modular_monolith,Modular Monolith,"Một khối triển khai duy nhất (Single Deployment Unit) nhưng bên trong được chia tách nghiêm ngặt thành các module độc lập theo nghiệp vụ (Domain). Các module giao tiếp qua Public Interface, không gọi trực tiếp Database của nhau.","Lựa chọn số 1 cho Startup và Team < 20 người năm 2025. Phù hợp cho dự án mới cần tốc độ phát triển nhanh nhưng vẫn giữ được khả năng mở rộng sau này.","[Ưu] Dễ triển khai (1 pipeline), zero-latency khi gọi hàm nội bộ, ACID transaction đơn giản, dễ refactor. [Nhược] Cần kỷ luật code cao để tránh biến thành ""Spaghetti Code"", scale toàn bộ khối thay vì từng phần nhỏ.",Internal Event Bus | Public APIs (Java Interface/Rust Trait) | Shared DB with Schema separation,Domain-Driven Design (DDD) | Vertical Slice
arch_microservices,Microservices Architecture,"Hệ thống được chia nhỏ thành các dịch vụ độc lập, chạy trên các process riêng biệt, giao tiếp qua mạng (HTTP/gRPC/MsgQueue). Mỗi dịch vụ có Database riêng.","Doanh nghiệp lớn (Enterprise), Team > 50 người, cần scale độc lập từng chức năng, đa dạng công nghệ (Polyglot), hệ thống cực kỳ phức tạp.","[Ưu] Scale linh hoạt, cô lập lỗi tốt, tự do chọn công nghệ cho từng service. [Nhược] Chi phí vận hành (DevOps) cực cao, độ trễ mạng, khó khăn trong Distributed Transaction (Saga pattern), debug phức tạp.",Service Discovery | API Gateway | Circuit Breaker | Distributed Tracing (OpenTelemetry),Saga Pattern | Database per Service | Strangler Fig
arch_serverless,Serverless / FaaS,"Mã nguồn được triển khai dưới dạng các hàm (Functions) chạy theo sự kiện (Event-triggered). Hạ tầng và khả năng mở rộng do Cloud Provider quản lý hoàn toàn.","Ứng dụng xử lý sự kiện không liên tục, MVP, Cron Jobs, xử lý ảnh/video, các tác vụ phụ trợ (Glues), Traffic tăng giảm đột biến khó đoán.","[Ưu] Pay-per-use (chi phí thấp khi ít traffic), không cần quản lý server, auto-scale vô cực. [Nhược] Cold-start latency (độ trễ khởi động), Vendor Lock-in cao, khó quản lý state (stateless), giới hạn thời gian chạy.",Function as a Service (Lambda/Azure Functions) | Event Source (S3/SQS) | Managed DB (DynamoDB),Event-Driven | Nano-services
arch_event_driven,Event-Driven Architecture (EDA),"Các thành phần hệ thống giao tiếp bằng cách phát (produce) và nhận (consume) các sự kiện (events) bất đồng bộ, thay vì gọi trực tiếp.","Hệ thống xử lý thời gian thực (Real-time), IoT, E-commerce (đặt hàng -> thanh toán -> kho), cần độ tách biệt (decoupling) cao giữa các service.","[Ưu] Decoupling tuyệt đối, dễ thêm tính năng mới mà không sửa code cũ, chịu tải tốt (buffering). [Nhược] Khó debug luồng chạy (flow), tính nhất quán cuối cùng (Eventual Consistency), phức tạp trong xử lý lỗi/retry.",Message Broker (Kafka/RabbitMQ) | Event Bus | Pub/Sub Mechanism,Observer Pattern | Pub-Sub | Reactor
arch_clean_hexagonal,Clean / Hexagonal Architecture,"Tách biệt hoàn toàn Business Logic (Core) khỏi các yếu tố bên ngoài như UI, Database, Framework bằng các ""Ports"" và ""Adapters"". Dependency trỏ ngược vào trong.","Dự án Core Banking, Fintech, các hệ thống có nghiệp vụ phức tạp cần tồn tại lâu dài (>5 năm), cần Unit Test nghiệp vụ triệt để.","[Ưu] Business Logic thuần khiết, dễ test, dễ thay đổi công nghệ (đổi DB/Framework không ảnh hưởng Logic). [Nhược] Nhiều boilerplate code, nhiều layer chuyển đổi dữ liệu, over-engineering với dự án nhỏ.",Domain Entities | Use Cases | Ports (Interfaces) | Adapters (Infrastructure),Dependency Inversion | Repository Pattern
arch_cqrs_es,CQRS + Event Sourcing,"Tách biệt luồng Ghi (Command) và luồng Đọc (Query). Lưu trữ trạng thái bằng chuỗi các sự kiện thay đổi (Event Log) thay vì trạng thái hiện tại.","Hệ thống tài chính, kế toán, Audit Log, hệ thống cần lịch sử thay đổi chính xác tuyệt đối, hoặc hệ thống có tỷ lệ Đọc/Ghi chênh lệch cực lớn.","[Ưu] Hiệu năng đọc cực cao (Optimized Read Models), truy vết lịch sử hoàn hảo, Time-travel debugging. [Nhược] Độ phức tạp cực cao, Eventual Consistency gây khó hiểu cho UX, khó thay đổi cấu trúc Event cũ.",Command Bus | Query Bus | Event Store | Read DB (Projections),Command Query Responsibility Segregation | Event Sourcing
arch_bff,Backend for Frontend (BFF),"Tạo ra các Backend riêng biệt tối ưu cho từng loại Client (Mobile App, Web, IoT) thay vì một API chung cho tất cả.","Hệ thống đa nền tảng (Super App), nơi Mobile cần dữ liệu gọn nhẹ ít request, còn Web cần nhiều thông tin chi tiết.","[Ưu] Tối ưu trải nghiệm Client, team Frontend chủ động logic hiển thị, tránh API ""cồng kềnh"" (over-fetching). [Nhược] Duplication logic giữa các BFF, tăng số lượng service cần bảo trì.",API Gateway per Client | Data Aggregation Layer,Gateway Aggregation | Adapter Pattern
arch_edge_compute,Edge / Global Distributed,"Logic backend được đẩy ra chạy tại các node mạng biên (Edge locations) gần người dùng nhất, thay vì tập trung tại một Region.","Ứng dụng yêu cầu độ trễ cực thấp (<50ms) toàn cầu: Gaming, Cá cược, AI Inference thời gian thực, Cá nhân hóa nội dung (CDN logic).","[Ưu] Tốc độ phản hồi ánh sáng, giảm tải cho Origin Server. [Nhược] Giới hạn tài nguyên (CPU/RAM) tại Edge, Database phân tán khó quản lý nhất quán, khó debug toàn cầu.",Edge Workers (Cloudflare/Vercel) | Global KV Store (Redis/Durable Objects),Edge Side Includes | Geo-DNS
arch_space_based,Space-Based Architecture,"Loại bỏ Database tập trung làm nút thắt cổ chai. Dữ liệu được lưu trữ và xử lý hoàn toàn trên RAM của lưới các node xử lý (Processing Grid).","Hệ thống High-frequency trading (HFT), Bán vé Concert, Gaming Server cần xử lý hàng triệu request/giây với độ trễ thấp.","[Ưu] Hiệu năng và khả năng mở rộng tuyến tính cực cao. [Nhược] Chi phí RAM lớn, phức tạp trong việc đồng bộ dữ liệu về Persistent Store, rủi ro mất dữ liệu khi sập nguồn toàn bộ.",In-Memory Data Grid (Hazelcast/Ignite) | Replication Manager,Tuple Space | Data Grid
arch_layered,Layered (N-Tier) Architecture,"Cấu trúc cổ điển chia hệ thống thành các tầng ngang: Presentation -> Business -> Persistence -> Database.","Các ứng dụng doanh nghiệp truyền thống (CRUD), CMS đơn giản, Team mới học việc cần cấu trúc dễ hiểu.","[Ưu] Dễ hiểu, dễ phân chia công việc theo chiều ngang (Frontend dev, Backend dev, DB admin). [Nhược] Dễ bị ""Sinkhole anti-pattern"" (request đi qua các tầng mà không xử lý gì), khó tách module dọc.",Presentation Layer | Service Layer | DAO/Repository Layer,MVC (Model-View-Controller)
arch_ai_agentic,AI Agentic Architecture (2025),"Kiến trúc xoay quanh các AI Agents tự chủ, sử dụng LLM làm hạt nhân xử lý, kết nối với Vector DB và Tool/API để thực hiện tác vụ phức tạp.","Ứng dụng GenAI, Customer Support tự động, Data Analyst Agent, hệ thống RAG (Retrieval-Augmented Generation).","[Ưu] Khả năng suy luận và xử lý vấn đề linh hoạt (Non-deterministic). [Nhược] Khó kiểm soát đầu ra (Hallucination), độ trễ cao do LLM inference, chi phí Token lớn.",LLM Orchestrator (LangChain) | Vector Database | Tool Interfaces,Retrieval-Augmented Generation (RAG) | ReAct Pattern
arch_bigdata_lambda,Lambda Architecture,"Kết hợp hai lớp xử lý: Batch Layer (xử lý lô chính xác cao) và Speed Layer (xử lý luồng thời gian thực) để cung cấp view dữ liệu tổng hợp.","Hệ thống Analytics, Dashboard báo cáo thời gian thực, xử lý Log khổng lồ, IoT data pipeline.","[Ưu] Cân bằng giữa độ trễ thấp và độ chính xác cao, chịu lỗi tốt. [Nhược] Phức tạp vì phải duy trì 2 logic xử lý song song (Batch & Speed), code duplicate.",Batch Processing (Spark) | Stream Processing (Flink/Kafka Streams) | Serving Layer,MapReduce | Stream Processing